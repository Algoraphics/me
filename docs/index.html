<head>
    <meta charset="utf-8">
    <title>Ethan Rabb: The Website</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link rel="shortcut icon" href="Exbot.jpg" type="image/x-icon" />
    <script>
        // Hardcoded here because we need to set the z-index manually for github pages
        // -- https://xemantic.github.io/shader-web-background/
        const shaderWebBackground = {}; (() => {
            'use strict'; const t = (a, b) => {
                b.initHalfFloatRGBATexture(b.width, b.height); a.texParameteri(a.TEXTURE_2D,
                    a.TEXTURE_MIN_FILTER, a.LINEAR); a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER,
                        a.LINEAR); a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_S, a.CLAMP_TO_EDGE); a.texParameteri(a.TEXTURE_2D,
                            a.TEXTURE_WRAP_T, a.CLAMP_TO_EDGE)
            }, x = (a, b) => {
                console.warn("shader-web-background cannot shade, adding fallback CSS classes");
                document.documentElement.classList.add("shader-web-background-fallback"); b.classList.add("shader-web-background-fallback");
                if (a instanceof shaderWebBackground.GlError) console.warn("Not sufficient WebGL support:",
                    a); else throw a;
            };
            function y(a, b) { if (!a) throw new shaderWebBackground.ConfigError(b); }
            function z(a) {
                y(a instanceof HTMLCanvasElement, "config.canvas must be instance of canvas");
                return a
            }
            function A() {
                const a = document.createElement("canvas"), b = a.style; a.id = "shader-web-background"; b.width =
                    "100vw"; b.height = "100vh"; b.position = "fixed"; b.top = "0"; b.left = "0"; b.zIndex = 0; return a
            }
            function B(a, b, c) {
                y(a instanceof HTMLScriptElement && a.type === b, 'Shader source element of id "' +
                    c + '" should be of type: <script type="' + (b + '" id="' + c + '">'))
            }
            function D(a) {
                const b = document.getElementById(a); y(b, 'Missing shader source: <script type="x-shader/x-fragment" id="' +
                    (a + '">')); B(b, "x-shader/x-fragment", a); return b.text
            }
            function E(a) {
                a += "Vertex"; const b = document.getElementById(a); return b ? (B(b, "x-shader/x-vertex",
                    a), b.text) : "attribute vec2 V;void main(){gl_Position=vec4(V,0,1);}"
            }
            function F(a, b) { "loading" !== document.readyState ? b() : window.addEventListener(a, b) }
            class G {
                constructor(a, b, c, d) {
                    this.g = c; const l = a.gl; this.h = () => {
                        for (const f of d) f.u(l,
                            f.location, b)
                    }; this.i = () => {
                        var f = c.v, h = a.gl; h.bindBuffer(h.ARRAY_BUFFER, a.j); h.enableVertexAttribArray(f);
                        h.vertexAttribPointer(f, 2, h.FLOAT, !1, 0, 0); h.drawArrays(h.TRIANGLE_STRIP, 0, 4); h.disableVertexAttribArray(f);
                        h.bindBuffer(h.ARRAY_BUFFER, null); f = a.gl; for (h = 0; h < a.g; h++)f.activeTexture(f.TEXTURE0 +
                            h), f.bindTexture(f.TEXTURE_2D, null); a.g = 0
                    }
                }
            }
            function H(a) {
                var b = { antialias: !1, depth: !1, alpha: !1 }; try { return new I(a, b) } catch (c) {
                    throw new shaderWebBackground.GlError(c.message);
                }
            }
            function J(a, b, c, d, l, f) {
                function h(e, m, n) {
                    try {
                        {
                            var k = p; const q = k.gl, P = K(k, e, q.VERTEX_SHADER, m),
                                Q = K(k, e, q.FRAGMENT_SHADER, n), v = q.createProgram(); q.attachShader(v, P); q.attachShader(v,
                                    Q); q.linkProgram(v); var r = v
                        } return r
                    } catch (q) {
                        throw new shaderWebBackground.ConfigError(q.message);
                    }
                } const p = H(a), w = [], g = {
                    gl: p.gl, canvas: a, width: 0, height: 0, cssPixelRatio: 0, cssWidth: 0,
                    cssHeight: 0, isOverShader: (e, m) => {
                        const n = a.getBoundingClientRect(); return e >= n.left &&
                            e <= n.right && m >= n.top && m <= n.bottom
                    }, toShaderX: e => (e - a.getBoundingClientRect().left) *
                        g.cssPixelRatio + .5, toShaderY: e => a.height - (e - a.getBoundingClientRect().top) * g.cssPixelRatio -
                            .5, s: () => g.cssWidth !== a.clientWidth || g.cssHeight !== a.clientHeight ? (g.resize(), !0) :
                                !1, resize: () => {
                                    const e = window.devicePixelRatio || 1, m = a.clientWidth, n = a.clientHeight,
                                        k = Math.floor(m * e), r = Math.floor(n * e); a.width = k; a.height = r; g.width = k; g.height = r; g.cssPixelRatio =
                                            e; g.cssWidth = m; g.cssHeight = n; p.gl.viewport(0, 0, p.canvas.width, p.canvas.height); for (const q of w) q.g.l(k,
                                                r)
                                }, texture: (e, m) => {
                                    {
                                        var n = p; const k = n.gl; m = m instanceof L ? m.g : m; k.activeTexture(k.TEXTURE0 +
                                            n.g); k.bindTexture(k.TEXTURE_2D, m); k.uniform1i(e, n.g++)
                                    }
                                }, buffers: {}, initHalfFloatRGBATexture: (e,
                                    m) => { p.h.g(e, m) }
                }, R = Object.keys(b).length - 1; let S = 0; for (const e in b) {
                    if (S++ < R) {
                        const k =
                            b[e].texture || t; g.buffers[e] = M(p, () => { k(p.gl, g) })
                    } const m = N(p, h(e, E(e), D(e)), g.buffers[e]),
                        n = b[e].uniforms || {}; var u = Object.keys(n); for (const k of m.m) y(n[k.name], 'No configuration for uniform "' +
                            k.name + '" defined in shader "' + e + '"'), u = u.filter(r => r !== k.name); 0 !== u.length && console.warn('Extra uniforms configured for shader "' +
                                e + '", which are not present in the shader code - might have been removed by GLSL compiler if not used: ' +
                                u.join(", ")); u = m.m.map(k => ({ location: k.location, u: n[k.name] })); w.push(new G(p, g,
                                    m, u))
                } const C = () => {
                    g.s() && d && d(g.width, g.height, g); l && l(g); for (const e of w) e.g.i(e.h,
                        e.i); f && f(g); requestAnimationFrame(C)
                }; F("load", () => {
                    g.resize(); c && c(g); d && d(g.width,
                        g.height, g); requestAnimationFrame(C)
                }); return g
            }
            shaderWebBackground.Error = class extends Error { constructor(a) { super(a); this.name = "shaderWebBackground.Error" } };
            shaderWebBackground.ConfigError = class extends shaderWebBackground.Error {
                constructor(a) {
                    super(a);
                    this.name = "shaderWebBackground.ConfigError"
                }
            };
            shaderWebBackground.GlError = class extends shaderWebBackground.Error {
                constructor(a) {
                    super(a); this.name =
                        "shaderWebBackground.GlError"
                }
            };
            shaderWebBackground.shade = function (a) {
                y(a, "Missing config argument"); const b = a.canvas ?
                    z(a.canvas) : A(); y(a.shaders, "No shaders specified in config"); try {
                        const c = J(b, a.shaders,
                            a.onInit, a.onResize, a.onBeforeFrame, a.onAfterFrame); a.canvas || F("DOMContentLoaded",
                                () => { document.body.appendChild(b) }); return c
                    } catch (c) { (a.onError || x)(c, b) }
            }; const O = [-1, 1, 1, 1, -1, -1, 1, -1];
            function T(a, b) { return a.j(a.gl.getExtension(b), b + " extension is not supported") }
            class U { constructor(a, b) { this.gl = a; this.j = b } g() { } }
            class V extends U {
                constructor(a, b) {
                    super(a, b); this.h = T(this, "OES_texture_half_float");
                    T(this, "OES_texture_half_float_linear")
                } g(a, b) {
                    const c = this.gl; c.texImage2D(c.TEXTURE_2D,
                        0, c.RGBA, a, b, 0, c.RGBA, this.h.HALF_FLOAT_OES, null)
                }
            }
            class W extends U {
                constructor(a, b) { super(a, b); T(this, "EXT_color_buffer_float"); this.gl.getExtension("OES_texture_float_linear") } g(a,
                    b) {
                    const c = this.gl; c.texImage2D(c.TEXTURE_2D, 0, c.RGBA16F, a, b, 0, c.RGBA, c.HALF_FLOAT,
                        null)
                }
            }
            function X(a) {
                a = a.split(/\r?\n/); const b = a.length.toString().length; var c = []; a.forEach((d,
                    l) => {
                    l = (l + 1).toString(); l = l.length >= b ? l : " ".repeat(b - l.length) + l; c.push(l + ": " + d +
                        "\n")
                }); return c.join("")
            } function M(a, b) { return new L(a.gl, () => { b(a.gl) }) }
            function N(a, b, c) {
                const d = a.gl; a = []; const l = d.getProgramParameter(b, d.ACTIVE_UNIFORMS);
                for (let f = 0; f < l; f++) {
                    const h = d.getActiveUniform(b, f); a.push({
                        name: h.name, location: d.getUniformLocation(b,
                            h.name)
                    })
                } return {
                    v: d.getAttribLocation(b, "V"), m: a, l: c ? (f, h) => c.l(f, h) : () => { }, i: (f,
                        h) => { d.useProgram(b); f(); c ? (f = c.g, c.g = c.h, c.h = f, c.i(h)) : h() }
                }
            }
            function K(a, b, c, d) {
                a = a.gl; c = a.createShader(c); a.shaderSource(c, d); a.compileShader(c);
                if (!a.getShaderParameter(c, a.COMPILE_STATUS)) {
                    const l = String(a.getShaderInfoLog(c));
                    a.deleteShader(c); b = "Cannot compile shader - " + b + ": " + l; console.log(b); console.log(X(d));
                    throw Error(b);
                } return c
            }
            class I {
                constructor(a, b) {
                    this.canvas = a; const c = (l, f) => { if (!l) throw Error(f); return l };
                    let d = a.getContext("webgl2", b); if (d) this.h = new W(d, c); else if (d = a.getContext("webgl",
                        b)) this.h = new V(d, c); c(d, "webgl context not supported on supplied canvas element: " +
                            a); this.gl = d; a = d.createBuffer(); d.bindBuffer(d.ARRAY_BUFFER, a); d.bufferData(d.ARRAY_BUFFER,
                                new Float32Array(O), d.STATIC_DRAW); d.bindBuffer(d.ARRAY_BUFFER, null); this.j = a; this.buffers =
                                    {}; this.g = 0
                }
            }
            function Y(a) {
                const b = a.gl, c = b.createTexture(); b.bindTexture(b.TEXTURE_2D, c); a.o(b);
                b.bindTexture(b.TEXTURE_2D, null); return c
            }
            class L {
                constructor(a, b) {
                    this.j = a.createFramebuffer(); this.gl = a; this.o = b; this.g = this.h =
                        null
                } l() {
                    this.h && this.gl.deleteTexture(this.h); this.g && this.gl.deleteTexture(this.g);
                    this.h = Y(this); this.g = Y(this)
                } i(a) {
                    const b = this.gl; b.bindFramebuffer(b.FRAMEBUFFER,
                        this.j); b.framebufferTexture2D(b.FRAMEBUFFER, b.COLOR_ATTACHMENT0, b.TEXTURE_2D, this.g,
                            0); a(); b.framebufferTexture2D(b.FRAMEBUFFER, b.COLOR_ATTACHMENT0, b.TEXTURE_2D, null,
                                0); b.bindFramebuffer(b.FRAMEBUFFER, null)
                }
            };
        })()
        //# sourceMappingURL=shader-web-background.min.js.map
    </script>

    <style>
        .shader-web-background-fallback {
            background-color: #212121;
            background-position: center;
            background-size: cover;
            background-attachment: fixed;
        }
    </style>
</head>
<body>
    <div id="root"></div>
    <!-- scripts -->
    <script src="./dist/app-bundle.js"></script>
    <script type="x-shader/x-fragment" id="image">
        #ifdef GL_ES
        precision highp float;
        #endif

        uniform float iActive;
        uniform float powerLevel;
        uniform float useMouse;
        uniform float iTime;
        uniform vec2 iMouse;
        uniform vec2 iResolution;
        uniform float warpStrength;
        uniform float inversionRadius;
        uniform float shapeMorph;
        uniform float contrastLevel;
        uniform float shiftAmount;
        uniform float colorShiftR;
        uniform float colorShiftG;
        uniform float colorShiftB;
        uniform vec2 clickPos1;
        uniform float clickElapsed1;
        uniform vec2 clickPos2;
        uniform float clickElapsed2;
        uniform vec2 clickPos3;
        uniform float clickElapsed3;
        uniform vec2 clickPos4;
        uniform float clickElapsed4;
        uniform vec2 clickPos5;
        uniform float clickElapsed5;

        #define time (iTime / 3.)
        #define PI 3.14159265358979323846
        #define resolution iResolution
        #define mouse iMouse

        float box(vec2 _st, vec2 _size, float _smoothEdges){
            _size = vec2(1.75)-_size*0.75;
            vec2 aa = vec2(_smoothEdges*0.5);
            vec2 uv = smoothstep(_size,_size+aa,_st);
            uv *= smoothstep(_size,_size+aa,vec2(1.0)-_st);
            return uv.x*uv.y;
        }

        float circle(vec2 _st, float _radius, float _smoothEdges){
            vec2 dist = _st - vec2(0.5);
            return 1.0 - smoothstep(_radius - (_smoothEdges * 0.5),
                                     _radius + (_smoothEdges * 0.5),
                                     dot(dist, dist) * 4.0);
        }

        float morphedShape(vec2 _st, vec2 _size, float _smoothEdges, float morph){
            float boxShape = box(_st, _size, _smoothEdges);
            float circleShape = circle(_st, 0.5, _smoothEdges);
            return mix(boxShape, circleShape, morph);
        }

        vec2 tile(vec2 _st, float _zoom){
            _st *= _zoom;
            return fract(_st);
        }

        vec2 rotate2D(vec2 _st, float _angle, vec2 shift){
            _st -= 0.5 + shift.x;
            _st =  mat2(cos(_angle),-sin(_angle),
                        sin(_angle),cos(_angle)) * _st;
            _st += 0.5 + shift.y;
            return _st;
        }

        vec2 domainWarp(vec2 p, float strength, float tm) {
            if (strength > 0.0) {
                float freq = 1.0 + strength * 2.0;
                float timeVar = tm * 0.3;
                
                vec2 q = vec2(
                    sin(p.x * freq * 1.3 + p.y * freq * 0.8 + timeVar),
                    cos(p.y * freq * 1.1 + p.x * freq * 0.9 - timeVar * 0.7)
                );
                
                vec2 r = vec2(
                    cos(p.x * freq * 0.7 - q.y * 2.0 + timeVar * 0.5),
                    sin(p.y * freq * 0.9 + q.x * 2.0 - timeVar * 0.3)
                );
                
                return p + (q * strength * 0.4) + (r * strength * strength * 0.3);
            }
            return p;
        }

        void main(void){
            vec2 v = (gl_FragCoord.xy - resolution/2.0) / min(resolution.y,resolution.x) * 5.0;
            vec2 vv = v; vec2 vvv = v;
            float tm = time*0.05;
            vec2 mspt = (vec2(
                    sin(tm)+cos(tm*0.2)+sin(tm*0.5)+cos(tm*-0.4)+sin(tm*1.3),
                    cos(tm)+sin(tm*0.1)+cos(tm*0.8)+sin(tm*-1.1)+cos(tm*1.5)
                    )+4.0)*0.03;
            vec2 resV = ( gl_FragCoord.xy / resolution );
            float aspectRatio = resolution.x / resolution.y;
            vec2 mouseDiff = (resV - mouse) * vec2(aspectRatio, 1.0);
            float bdist = useMouse*clamp(1.5 - 6.*length(mouseDiff), 0., 1.);
            
            float rippleSpeed = 0.2;
            float rippleWidth = 0.05;
            float ripple = 0.0;
            
            if (useMouse > 0.5) {
                if (clickElapsed1 >= 0.0 && clickElapsed1 < 2.0) {
                    vec2 diff1 = (resV - clickPos1) * vec2(aspectRatio, 1.0);
                    float r1 = clickElapsed1 * rippleSpeed;
                    float d1 = abs(length(diff1) - r1);
                    ripple = max(ripple, (1.0 - smoothstep(0.0, rippleWidth, d1)) * (1.0 - clickElapsed1 / 2.0));
                }
                
                if (clickElapsed2 >= 0.0 && clickElapsed2 < 2.0) {
                    vec2 diff2 = (resV - clickPos2) * vec2(aspectRatio, 1.0);
                    float r2 = clickElapsed2 * rippleSpeed;
                    float d2 = abs(length(diff2) - r2);
                    ripple = max(ripple, (1.0 - smoothstep(0.0, rippleWidth, d2)) * (1.0 - clickElapsed2 / 2.0));
                }
                
                if (clickElapsed3 >= 0.0 && clickElapsed3 < 2.0) {
                    vec2 diff3 = (resV - clickPos3) * vec2(aspectRatio, 1.0);
                    float r3 = clickElapsed3 * rippleSpeed;
                    float d3 = abs(length(diff3) - r3);
                    ripple = max(ripple, (1.0 - smoothstep(0.0, rippleWidth, d3)) * (1.0 - clickElapsed3 / 2.0));
                }
                
                if (clickElapsed4 >= 0.0 && clickElapsed4 < 2.0) {
                    vec2 diff4 = (resV - clickPos4) * vec2(aspectRatio, 1.0);
                    float r4 = clickElapsed4 * rippleSpeed;
                    float d4 = abs(length(diff4) - r4);
                    ripple = max(ripple, (1.0 - smoothstep(0.0, rippleWidth, d4)) * (1.0 - clickElapsed4 / 2.0));
                }
                
                if (clickElapsed5 >= 0.0 && clickElapsed5 < 2.0) {
                    vec2 diff5 = (resV - clickPos5) * vec2(aspectRatio, 1.0);
                    float r5 = clickElapsed5 * rippleSpeed;
                    float d5 = abs(length(diff5) - r5);
                    ripple = max(ripple, (1.0 - smoothstep(0.0, rippleWidth, d5)) * (1.0 - clickElapsed5 / 2.0));
                }
            }
            
            float tdist = 1.0 - 0.2*bdist - ripple * 0.4;
            vec2 vdist = vec2(distance(mouse.x, resV.x), distance(mouse.y, resV.y));

            if (powerLevel < -1.0) {
                gl_FragColor = vec4(0., 0., 0., 1.);
            }
            else {
            float offset = 10.;
            float speed = 0.1;
            float R = 0.0+offset*sin(0.6*speed*tm);
            float RR = 0.0+offset*sin(1.3*speed*tm);
            float RRR = 0.0+offset*sin(speed*tm);
            float a = (.6-mspt.x)*6.2;
            float C = cos(a);
            float S = sin(a);
            vec2 xa=vec2(C, -S);
            vec2 ya=vec2(S, C);
            vec2 shift = vec2( 1.2, 1.62) + vec2(shiftAmount * 0.5, -shiftAmount * 0.3);
            float Z = 1.0 + mspt.y*6.0;
            float ZZ = 1.0 + (mspt.y)*6.2;
            float ZZZ = 1.0 + (mspt.y)*6.9;

            vec2 b = gl_FragCoord.xy/(resolution);
            b = rotate2D(b, PI*Z, 0.05*xa);

            int stop = 20;

            for ( int i = 0; i < 30; i++ ) {
                stop = 10 + int(powerLevel * 10.);
                if (i > stop) {
                    break;
                }
                float br = dot(b,b);
                float r = dot(v,v);
                float off = 3.+0.5*sin(0.1*tm);
                float invThreshold = (sin(tm) + off) * inversionRadius;
                if ( r > invThreshold )
                {
                    r = invThreshold/r ;
                    v.x = v.x * r;
                    v.y = v.y * r;
                }
                if ( br > 0.75 )
                {
                    br = (0.56)/br ;
                }

                R *= 1.05;
                R += br;
                if(i < (stop - 1)){
                    RR *= 1.05;
                    RR += br;
                    if(i < (stop - 2)){
                        RRR *= 1.05;
                        RRR += br;
                    }
                }

                float warpVariation = warpStrength * 0.15 * (sin(tm * 0.8) + sin(tm * 1.3) * 0.5);
                float dynamicWarp = warpStrength + warpVariation;
                v = domainWarp(v, dynamicWarp, tm);
                v = vec2( dot(v, xa), dot(v, ya)) * Z + shift;
                b = vec2(morphedShape(v,vec2(5.*tdist),0.9*tdist, shapeMorph)) + shift * 0.42;
            }
            float c = ((mod(R,2.0)>1.0)?1.0-fract(R):fract(R));
            float cc = ((mod(RR,2.0)>1.0)?1.0-fract(RR):fract(RR));
            float ccc = ((mod(RRR,2.0)>1.0)?1.0-fract(RRR):fract(RRR));
            float gray = ccc+cc+c / 3. - 0.8;

            vec3 baseColor = vec3(cc, c, ccc);
            float patternValue = (R + RR + RRR) / 3.0;
            
            float localShiftR = sin(patternValue + colorShiftR * 10.0) * 0.5;
            float localShiftG = sin(patternValue + colorShiftG * 10.0) * 0.5;
            float localShiftB = sin(patternValue + colorShiftB * 10.0) * 0.5;
            
            vec3 finalColor = clamp(baseColor + vec3(localShiftR, localShiftG, localShiftB), 0.0, 1.0);

            if (contrastLevel > 0.01) {
                float patternValue = mod(R + RR + RRR, 6.0) / 6.0;
                float threshold = pow(contrastLevel, 0.7) * 0.995;
                float edge = 0.02;
                float blackoutAmount = 1.0 - smoothstep(threshold - edge, threshold + edge, patternValue);
                finalColor = mix(finalColor, vec3(0.0, 0.0, 0.0), blackoutAmount);
            }

            vec4 color = vec4(finalColor, 1.);
            vec4 grayscale = vec4(gray,gray,gray, 1.);
            gl_FragColor = color*iActive + (1. - iActive)*grayscale;
            }
        }
    </script>
    <script>

        var minDimension;
        var time = performance.now() / 1000 + 100.;

        function modulatedWave(time, min, max, seed, bias = 2.5, speedMult = 1.0) {
            const fastWave = 
                Math.sin(time * 0.015 * speedMult + seed) * 0.4 +
                Math.sin(time * 0.027 * speedMult + seed * 2.1) * 0.3 +
                Math.sin(time * 0.041 * speedMult + seed * 3.7) * 0.2 +
                Math.cos(time * 0.033 * speedMult + seed * 1.3) * 0.1;
            
            const slowWave = Math.sin(time * 0.003 * speedMult + seed * 5.2);
            const amplitudeModulation = 0.15 + (slowWave * 0.5 + 0.5) * 0.85;
            
            const modulated = fastWave * amplitudeModulation;
            
            const normalized = (modulated + 1.0) / 2.0;
            const biased = Math.pow(normalized, bias);
            
            return min + biased * (max - min);
        }

        var mouseX;
        var mouseY;
        var activate = 0.;
        var powerLevel = -0.2;
        var mouse = 1.0;
        
        var warpStrength = 0.0;
        var inversionRadius = 1.0;
        var shapeMorph = 0.0;
        var contrastLevel = 0.75;
        var shiftAmount = 0.0;
        var colorShiftR = 0.0;
        var colorShiftG = 0.0;
        var colorShiftB = 0.0;
        var clickPositions = [{x: 0.5, y: 0.5}, {x: 0.5, y: 0.5}, {x: 0.5, y: 0.5}, {x: 0.5, y: 0.5}, {x: 0.5, y: 0.5}];
        var clickTimes = [-100, -100, -100, -100, -100];
        var clickIndex = 0;
        var rippleElapsed = [-100, -100, -100, -100, -100];
        document.addEventListener("mousemove", (event) => {
            mouseX = event.clientX;
            mouseY = event.clientY;
        });

        document.addEventListener("click", (event) => {
            if (mouse > 0.5) {
                var target = event.target;
                if (target instanceof HTMLButtonElement || 
                    target instanceof HTMLImageElement ||
                    target.closest('button')) {
                    return;
                }
                clickPositions[clickIndex] = {
                    x: event.clientX / window.innerWidth,
                    y: 1.0 - (event.clientY / window.innerHeight)
                };
                clickTimes[clickIndex] = performance.now() / 1000;
                clickIndex = (clickIndex + 1) % 5;
            }
        });

        document.addEventListener("mousedown", (event) => {
            if (event.buttons !== 1) {
                return;
            }
            var target = event.target;
            if (target instanceof HTMLButtonElement || target instanceof HTMLImageElement) {
                if (target.innerText === "Demo") {
                    if (activate === 0.) {
                        if (powerLevel <= -1.1) {
                            powerLevel = -1.
                        }
                        activate = 0.01;
                    }
                }
                else if (target.innerText === "Pause" || target.title === "Pause") {
                    timeAdd = 0.;
                }
                else if (target.innerText === "Play" || target.title === "Play") {
                    timeAdd = 0.5;
                }
                else if (target.innerText === "Rewind" || target.title === "Rewind") {
                    if (timeAdd > 0.) {
                        timeAdd = 0.;
                    }
                    timeAdd -= 2.5;
                }
                else if (target.innerText === "Fast Forward" || target.title === "Fast Forward") {
                    if (timeAdd < 0.) {
                        timeAdd = 0.;
                    }
                    timeAdd += 2.5;
                }
                else if (target.innerText === "Increase Complexity" || target.title === "Increase Complexity") {
                    if (powerLevel < 2.) {
                        powerLevel += 0.1;
                    }
                }
                else if (target.innerText === "Decrease Complexity" || target.title === "Decrease Complexity") {
                    if (powerLevel >= -1.1) {
                        powerLevel -= 0.1;
                    }
                }
                else if (target.innerText === "Toggle Cursor Interactivity" || target.title === "Toggle Cursor Interactivity") {
                    mouse = 1 - mouse;
                }
                else if (target.innerText === "Random Jump" || target.title === "Random Jump") {
                    const randomOffset = (Math.random() * 10000) - 5000;
                    time += randomOffset;
                    powerLevel = 0.8;
                }
                else if (target.innerText === "Fullscreen" || target.title === "Fullscreen") {
                    if (!document.fullscreenElement) {
                        powerLevel = 0.8;
                        document.documentElement.requestFullscreen().catch(err => {
                            console.log('Error attempting to enable fullscreen:', err);
                        });
                    } else {
                        if (document.exitFullscreen) {
                            document.exitFullscreen();
                        }
                    }
                }
                else if (target.innerText === "About Me" || target.innerText === "Work" || target.innerText === "Art") {
                    activate = 0.;
                    powerLevel = 0.;
                    timeAdd = 1.;
                }
            }
        });

        document.addEventListener('fullscreenchange', () => {
            const controlButtons = document.getElementById('controlbuttons');
            const root = document.getElementById('root');
            if (document.fullscreenElement) {
                if (controlButtons) controlButtons.style.display = 'none';
                if (root) root.style.display = 'none';
            } else {
                if (controlButtons) controlButtons.style.display = '';
                if (root) root.style.display = '';
            }
        });

        document.addEventListener('keydown', (event) => {
            if ((event.key === 'h' || event.key === 'H') && document.fullscreenElement) {
                const controlButtons = document.getElementById('controlbuttons');
                if (controlButtons) {
                    controlButtons.style.display = controlButtons.style.display === 'none' ? '' : 'none';
                }
            }
        });

        // FPS Checker (occasionally calculates FPS and lowers the power level if it's really bad)
        var fpsCheck = false;
        var times = [];
        let fps = 60;
        let checkCounter = 300;

        function refreshLoop() {
            window.requestAnimationFrame(() => {
                checkCounter++;
                if (checkCounter > 420) {
                    fpsCheck = false;
                }
                else if (checkCounter > 300) {
                    const now = performance.now();
                    while (times.length > 0 && times[0] <= now - 1000) {
                        fpsCheck = true;
                        times.shift();
                    }
                    times.push(now);
                    fps = times.length;
                    if (fpsCheck && !activate && fps < 25) {
                        console.log("Low FPS of " + fps + ". Lowering power.");
                        powerLevel -= 0.5;
                        fpsCheck = false;
                    }
                }
                if (!fpsCheck) {
                    checkCounter = 0;
                    times = [];
                }
                refreshLoop();
            });
        }

        refreshLoop();

        var stMouseX;
        var stMouseY;

        shaderWebBackground.shade({
            onResize: (width, height) => {
                minDimension = Math.min(width, height);
            },
            onInit: (ctx) => {
                mouseX = ctx.cssWidth / 2.;
                mouseY = ctx.cssHeight / 2.;
                timeAdd = 0.5;
            },
            onBeforeFrame: (ctx) => {
                if (activate > 0. && activate <= 1.) {
                    activate += 0.002;
                }
                var totalAdd = timeAdd;
                // Mobile doesn't seem to run as fast so we speed up the visual
                if (window.innerWidth <= 1000) {
                    totalAdd *= 2.;
                }
                time = time + (totalAdd / 50);

                warpStrength = modulatedWave(time, 0, 0.8, 123.45, 2.0, 1.0);
                shapeMorph = modulatedWave(time, -0.5, 1.5, 456.78, 1.5, 1.37);
                inversionRadius = modulatedWave(time, 0.5, 5, 789.12, 1.5, 0.83);
                var animatedContrast = modulatedWave(time, 0, 1.0, 567.89, 1.75, 0.97);
                contrastLevel = 0.75 * (1 - activate) + animatedContrast * activate;
                shiftAmount = modulatedWave(time, -5, 5, 135.79, 2.5, 1.19);

                const shiftRMag = modulatedWave(time, 0, 0.3, 345.67, 1.5, 1.13);
                colorShiftR = shiftRMag * Math.sin(time * 0.019 + 345.67);
                
                const shiftGMag = modulatedWave(time, 0, 0.3, 678.90, 1.25, 1.47);
                colorShiftG = shiftGMag * Math.sin(time * 0.023 + 678.90);
                
                const shiftBMag = modulatedWave(time, 0, 0.3, 901.23, 1.5, 0.89);
                colorShiftB = shiftBMag * Math.sin(time * 0.029 + 901.23);

                const currentRealTime = performance.now() / 1000;
                for (let i = 0; i < 5; i++) {
                    rippleElapsed[i] = currentRealTime - clickTimes[i];
                }

                stMouseX = ctx.toShaderX(mouseX) / ctx.width;
                stMouseY = (ctx.toShaderY(mouseY) / ctx.height);
            },
            shaders: {
                image: {
                    uniforms: {
                        iResolution: (gl, loc, ctx) => gl.uniform2f(loc, ctx.width, ctx.height),
                        iTime: (gl, loc) => gl.uniform1f(loc, time),
                        iMouse: (gl, loc) => gl.uniform2f(loc, stMouseX, stMouseY),
                        iActive: (gl, loc) => gl.uniform1f(loc, activate),
                        powerLevel: (gl, loc) => gl.uniform1f(loc, powerLevel),
                        useMouse: (gl, loc) => gl.uniform1f(loc, mouse),
                        warpStrength: (gl, loc) => gl.uniform1f(loc, warpStrength),
                        inversionRadius: (gl, loc) => gl.uniform1f(loc, inversionRadius),
                        shapeMorph: (gl, loc) => gl.uniform1f(loc, shapeMorph),
                        contrastLevel: (gl, loc) => gl.uniform1f(loc, contrastLevel),
                        shiftAmount: (gl, loc) => gl.uniform1f(loc, shiftAmount),
                        colorShiftR: (gl, loc) => gl.uniform1f(loc, colorShiftR),
                        colorShiftG: (gl, loc) => gl.uniform1f(loc, colorShiftG),
                        colorShiftB: (gl, loc) => gl.uniform1f(loc, colorShiftB),
                        clickPos1: (gl, loc) => gl.uniform2f(loc, clickPositions[0].x, clickPositions[0].y),
                        clickElapsed1: (gl, loc) => gl.uniform1f(loc, rippleElapsed[0]),
                        clickPos2: (gl, loc) => gl.uniform2f(loc, clickPositions[1].x, clickPositions[1].y),
                        clickElapsed2: (gl, loc) => gl.uniform1f(loc, rippleElapsed[1]),
                        clickPos3: (gl, loc) => gl.uniform2f(loc, clickPositions[2].x, clickPositions[2].y),
                        clickElapsed3: (gl, loc) => gl.uniform1f(loc, rippleElapsed[2]),
                        clickPos4: (gl, loc) => gl.uniform2f(loc, clickPositions[3].x, clickPositions[3].y),
                        clickElapsed4: (gl, loc) => gl.uniform1f(loc, rippleElapsed[3]),
                        clickPos5: (gl, loc) => gl.uniform2f(loc, clickPositions[4].x, clickPositions[4].y),
                        clickElapsed5: (gl, loc) => gl.uniform1f(loc, rippleElapsed[4])
                    }
                }
            }
        });
    </script>
</body>